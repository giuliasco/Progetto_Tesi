\chapter{Introduzione}

I Motif, anche chiamati Graphlet o Pattern, sono piccoli sottografi connessi indotti di un grafo ed il loro conteggio è un problema ben noto del graph mining e dell'analisi dei social network. Pi\`u precisamente, dato in input un grafo $G$ e un intero positivo $k$, il problema richiede di contare,  per ogni graphlet $H$ di $k$ nodi, il numero di sottografi indotti di $G$ isomorfi ad $H$.
Comprendere la distribuzione dei motif in un grafo fa luce sul tipo di strutture locali presenti in esso che possono essere usate per molteplici tipi di analisi applicate, per esempio, a reti sociali \cite{bhuiyan2012guise,zhao2010subgraph,boldi2011layered}, biologiche \cite{alon2008biomolecular}, ecc \dots \ .\\
Poich\`e il conteggio esatto del numero di occorrenze dei graphlet risulta computazionalmente impegnativo, di solito ci si accontenta di obiettivi meno ambiziosi come la stima \emph{approssimata} della loro frequenza: per ogni sottografo di $k$ nodi si richiede di stimare, nel modo pi\`u accurato possibile, la sua frequenza relativa rispetto a tutti i sottografi della stessa dimensione (i.e., numero di nodi).
Dal momento che il numero di motif cresce più che esponenzialmente rispetto al numero di nodi $k$, spesso si restringe l'attenzione al problema della stima della frequenza relativa dei soli sottografi che compaiono il maggior numero di volte nel grafo input.
Ci sono due approcci principali per ottenere tali stime:
Il primo utilizza i metodi Monte Carlo basati sulle catene di Markov (MCMC), mentre il secondo sfrutta la tecnica del Color Coding introdotta da Alon, Yuster e Zwick \cite{alon1995color}.
Studi recenti analizzano le differenze tra i due approcci concludendo che, seppure  l'elevata complessit\`a spaziale delle tecniche basate sul color coding può limitarne l'utilizzo, tali tecniche forniscono garanzie di accuratezza migliori rispetto agli approcci MCMC.
Per tale motivo, nel resto di questa tesi ci concentreremo solo sulla tecnica del Color Coding.
Tale tecnica \`e stata introdotta per risolvere in maniera randomizzata il problema di determinare l'esistenza di sottografi isomorfi a cammini ed alberi con treewidth limitata nel grafo $G$ in input.
Un'estensione di questa tecnica consente inoltre di ottenere garanzie statistiche forti per il problema del Motif Counting da cui le frequenze possono essere facilmente derivate.
Tale estensione si basa su due osservazioni chiave.
La prima \`e che il Color Coding pu\`o essere usato per costruire ``un'urna'' astratta che contiene un sottoinsieme statisticamente rappresentativo di tutti i sottografi di $G$ (non necessariamente indotti) che hanno esattamente $ k $ nodi e sono alberi.
La seconda osservazione \`e che il compito di campionare $ k $-graphlet, ossia graphlet con $ k $ nodi, pu\`o essere ridotto a quello di campionare $ k $-alberi, ossia alberi con $ k $ nodi, dall'urna.
Si pu\`o cos\`i stimare il numero dei motif in due fasi: la ``fase di costruzione'' in cui si crea l'urna da $G$ e la ``fase di campionamento'' dove si ``estraggono'' degli alberi dall'urna fino ad ottenere delle stime accurate per i graphlet di interesse.

\section{Contributo della tesi}

In questo lavoro di tesi l'attenzione si è concentrata principalmente sull'ottimizzazione di un algoritmo basato sulle tecnica del Color Coding per il conteggio delle occorrenze di tutti i $k$-treelet presenti nel grafo $G$ in input, dove per $k$-treelet  si intendono alberi con $ k $ nodi ed un occorrenza di un $k$-treelet $T$ in $G$ è un sottografo (non necessariamente indotto) isomorfo a $T$.
Ci\`o corrisponde alla ``fase di costruzione'' descritta in precedenza. Tale fase pu\`o essere descritta mediante un algoritmo basato sulla tecnica della programmazione dinamica.
In primo luogo, tramite il lavoro svolto, si \`e implementato l'algoritmo descritto in  \cite{bressan2018motif} in Java.
L'algoritmo, supposto di voler conteggiare i treelet di dimensione $ k $ di un grafo, lavora in esattamente  $k$ fasi.
Nell'$i$-esima fase (con $i \in \{1, \dots, k\}$), vengono conteggiati i treelet di dimensione $i$.
Tali conteggi saranno ottenuti in funzione della struttura del grafo e del numero di occorrenze dei treelet con un numero di nodi compreso tra $1$ ed $i-1$.
Ne segue che per poter calcolare il numero di occorrenze dei treelet di dimensione $ k $, sar\`a necessario aver gi\`a calcolato quelli di dimensione fino a $ k-1$.
Tale dipendenza \`e evidenziata dalle formule di ricorrenza che descrivono l'algoritmo di programmazione dinamica, che verr\`a descritto nella sezione \ref{section1}.
Poich\`e il numero dei $ k $-treelet cresce in maniera esponenziale rispetto a $ k $, l'algoritmo pu\'o essere eseguito solo per valori piccoli di $ k $ prima che il tempo richiesto diventi eccessivo.\\
A tal proposito nella tesi viene proposta un'ottimizzazione, basata su opportune decomposizioni ``bilanciate'' degli alberi, che consente di rendere indipendenti i conteggi dei treelet di dimensione $ k $ da circa un terzo dei conteggi precedenti.
Tale ottimizzazione permette di eseguire solo le prime $\frac{2}{3} k + O(1)$ (si veda la sezione \ref{cap 3:3} per maggiori dettagli) fasi prima della fase $ k $, comportando un risparmio notevole di tempo.\\
Inoltre è stata condotta un'analisi sperimentale su quattro grafi, con lo scopo di valutare l'accuratezza delle stime ottenute ed  il risparmio di tempo risultante dall'utilizzo dell'algoritmo ottimizzato rispetto a quello non ottimizzato.
Ad esempio, su un grafo sociale con circa 82K nodi e 870K archi, l'algoritmo  ottimizzato risparmia 7 minuti rispetto all'algoritmo non ottimizzato per arrivare a calcolare i treelet di dimensione $ k=10 $.


\section{Organizzazione del testo}

La tesi è `e strutturata nel seguente modo.
Nel capitolo 2 verr\`a descritta la tecnica del color coding e il suo utilizzo per il conteggio degli alberi.
Si vedr\`a l'algoritmo di \cite{bressan2018motif}, la sua formulazione e le scelte adottate in fase implementativa.
Nel capitolo 3 si discuter\`a in dettaglio la tecnica delle decomposizioni bilanciate ed il relativo impatto sull'algoritmo. Anche in questo caso si discuteranno le scelte effettuate in fase implementativa.
Nel capitolo 4 verranno mostrati i risultati dell'analisi sperimentale delle performance dell'algoritmo ottimizzato confrontandolo con l'implementazione della versione di \cite{bressan2018motif}.
Infine, nel capitolo 5, veranno discusse le possibili estensioni del presente lavoro di tesi al problema più generale della stima del numero di occorrenze dei graphlet.
