\chapter{Introduzione}

I Motif, anche chiamati Graphlet o Pattern, sono piccoli sottografi connessi indotti di un grafo, la conta dei motif \`e un problema ben noto del graph mining e dell'analisi dei social network.\\
Dato in input un grafo $G$ e un intero positivo $k$ il problema richiede di contare,  per ogni graphlet $H$ di $k$ nodi, il numero di sottografi indotti di $G$ isomorfi ad $H$.
Comprendere la distribuzione dei motif in un grafo fa luce sul tipo di strutture locali presenti in esso, che possono essere usate per una miriade di analisi, come ad esempio per l'analisi di reti sociali \cite{bhuiyan2012guise,zhao2010subgraph,boldi2011layered}, reti biologiche \cite{alon2008biomolecular}, etc$ \dots $
Poich\`e il conteggio dei graphlet pu\`o risultare computazionalmente impegnativo, di solito ci si accontenta di obiettivi meno ambiziosi.
Uno di questi \`e la stima approssimata della frequenza: per ogni sottografo si richiede di stimare, nel modo pi\`u accurato possibile, la sua frequenza relativa rispetto a tutti i sottografi della stessa dimensione.
Ancora meno ambiziosamente, visto che il numero di motif  cresce rispetto al numero $ k $, si restringe l'attenzione al problema della stima della frequenza relativa solo ai sottografi che compaiono il maggior numero di volte nel grafo input.
Ci sono due approcci per ottenere tali stime.
Il primo utilizza i metodi Monte Carlo,basati sulle catene di Markov, mentre il secondo sfrutta la tecnica del Color Coding introdotta da Alon, Yuster e Zwick \cite{alon1995color}.
Studi recenti analizzano le differenze tra i due approcci  concludendo come regola generale che il Color Coding \`e preferibile quando  la garanzia di accuratezza sui dati risulta fondamentale,  nonostante la complessit\'a spaziale che pu\`o limitarne l'utilizzo \cite{bressan2018motif}.
In questa tesi ci concentreremo solo sulla tecnica del Color Coding.
Tale tecnica \`e stata introdotta per risolvere in maniera randomizzata il problema di determinare l'esistenza di sottografi isomorfi a cammini ed alberi con treewidth limitata nel grafo $ G $ in input.
Un'estensione di questa tecnica consente di ottenere garanzie statistiche forti per il problema del Motif Counting, da cui le frequenze possono essere facilmente derivate.
Tale estensione si basa su due osservazioni chiave.
La prima \`e che il Color Coding pu\`o essere usato per costruire ``un'urna'' astratta che contiene un sottoinsieme statisticamente rappresentativo di tutti i sottografi di $G$ (non necessariamente indotti) che hanno esattamente $ k $ nodi e sono alberi.
La seconda osservazione \`e che il compito di campionare $ k $-graphlet, ossia graphlet con $ k $ nodi, pu\`o essere ridotto, con un overhead minimale, a campionare $ k $-alberi, alberi con $ k $ nodi, dall'urna.
Si pu\`o cos\`i stimare il numero dei motif in due fasi: la ``fase di costruzione'', in cui si crea l'urna da G e la ``fase di campionamento'', dove si campionano i graphlet fino ad ottenere delle stime accurate per quelli di interesse.


\section{Contributo della tesi}

In questo lavoro di tesi, l'attenzione \`e stata concentrata  sull'ottimizzazione di un algoritmo basato sulle tecnica del Color Coding per il conteggio di $k$-treelet all'interno di grafi pi\`u o meno grandi.
Per $ k $-treelet  si intendono alberi (non necessariamente indotti) in un grafo con $ k $ nodi.
\`E stato visto in uno studio del 2008 \cite{alon2008biomolecular}  su una rete PPI (Protein-Protein Interaction) quanto l'individuazione di $ k $-treelet in un grafo pu\`o essere utile per la ricerca della frequenza di particolari strutture biomolecolari, lo studio \'e stato svolto in particolare su reti di organismi unicellulari, che risultano tutti molto simili, e reti di organismi pluricellulari,che invece possono variare molto tra di loro.

Per effettuare il conteggio \`e stato necessario concentrarsi sulla fase costruttiva descritta in precedenza.

La fase costruttiva, \`e descritta mediante un algoritmo di programmazione dinamica, \`e un processo che richiede un grande impiego di tempo e spazio.
Il lavoro svolto ha portato, per prima cosa, ad un'implementazione in Java dell'algoritmo descritto in \cite{bressan2018motif}.
L'approccio dell'algoritmo supposto di dover conteggiare i treelet di dimensione $ k $ di un grafo, lavora in esattamente $ k $ fasi.
Nell'$ i $-esima fase saranno conteggiati i treelet di dimensione $ i $.
Tali conteggi saranno ottenuti in funzione della struttura del grafo e del numero di occorrenze dei treelet di dimensioni minore di $ i $.
Perci\`o per poter calcolare i treelet di dimensione $ k $, sar\`a necessario aver gi\`a calcolato quelli di dimensione fino a $ k-1 $.
Tale dipendenza \`e evidenziata dalle formule di ricorrenza che descrivono l'algoritmo di programmazione dinamica, che verr\`a descritto nella sezione \ref{section1}.
Poich\`e il numero dei $ k $-treelet cresce in maniera esponenziale rispetto a $ k $, l'algoritmo pu\'o essere eseguito solo per valori piccoli di $ k $, prima che il tempo richiesto diventi eccessivo.
A tal proposito nella tesi viene proposta un'ottimizzazione, basata su opportune decomposizioni ``bilanciate'' degli alberi, che consente di rendere indipendenti i conteggi dei treelet di dimensione $ k $ da $\frac{1}{3}$ dei conteggi precedenti.
Questo consente di eseguire le prime $\left\lceil \frac{2}{3} k\right\rceil$  fasi prima della fase $ k $, comportando un risparmio notevole di tempo.
Ad esempio su un grafo sociale con 63731 nodi e 817090 archi, l'algoritmo non ottimizzato richiede DA VEDERE tempo per la ricerca dei treelet con DA VEDERE nodi, mentre quello ottimizzato richiede un tempo DA VEDERE.



\section{Organizzazione del testo}

La descrizione del lavoro \`e strutturata nel seguente modo.
Nel capitolo 2 viene descritta la tecnica del color coding e il suo utilizzo per il conteggio degli alberi.
Si vedr\`a l'algoritmo di \cite{bressan2018motif} e la sua formulazione Si discuter\`a la scelta di adottata per l'implementazione e i suoi vantaggi.
Nel capitolo 3 si discuter\`a in dettaglio la tecnica delle decomposizioni bilanciate ed il relativo impatto sull'algoritmo. Anche in questo caso si discuteranno le scelte effettuate in fase implementativa.
Nel capitolo 4 verranno mostrati i risultati di un'analisi sperimentale delle performance dell'algoritmo ottimizzato rispetto alla versione di \cite{bressan2018motif}.
Infine, nel capitolo 5, veranno discusse le possibili estensioni del presente lavoro di tesi.
