\chapter{Color Coding}

Nel capitolo verr\`a descritta la tecnica del Color Coding utilizzata in questo studio.

La tecnica fu presentata per la prima volta nel 1995, da Alon, Yuster e Zwick \cite{alon1995color}.
In generale, dato un grafo $G = (V,E)$, il problema dell'isomorfismo dei sottografi  di $G$ \`e un problema $NP-completo$.
Il metodo del Color Coding permette di risolvere sottocasi di questo problema in tempo polinomiale.

Dati un grafo $ G = (V,E) $ ed uno $H = (V_H, E_H)$, i vertici $V$ di $G$, in cui verr\`a cercato un  sottografo isomorfo ad $H$, sono colorati casualmente di $k = |V_H|$ colori. Se $|V_H| = O(\log(V))$, allora, tutti i vertici del sottografo di $G$ isomorfo ad $H$, se esiste, saranno colorati da colori distinti.   

Il primo algoritmo descritto, per\`o, si limitava alla ricerca di sottografi indotti in un grafo, senza farne un conteggio.
 
\`E per questo motivo che in questo capitolo presenteremo un'estensione dell'algoritmo dato da Alon \cite{alon1995color}, per effettuare un conteggio dei Motif all'interno del grafo.
Dato in input un grafo $ G=(V,E) $ e un numero $ k $, per prima cosa il color coding assegna uniformemente e indipendentemente per ogni nodo di $ G $ un'etichetta in $ [k] := \{1,....,k\} $, indicato come un colore.
L'obiettivo \`è quello di conteggiare il numero di alberi colorati non indotti di $ k-nodi $ in $ G $ - chiamati $ treelet $ - i cui colori non sono ripetuti.
Questo viene fatto in maniera efficiente mediante una programmazione dinamica, tecnica bottom-up che identifica dei sottoproblemi del problema originario, procedendo logicamente dai problemi più piccoli verso quelli più grandi.
Grazie al fatto che alberi con insiemi disgiunti di colori devono giacere su insiemi digiunti di nodi.



\section{Algoritmo}

Qui descriviamo l'estensione dell'algoritmo del color coding che pu\`o contare e campionare treelet colorati non indotti uniformemnte a caso.
L'algoritmo consiste in una fase di costruzione e una fase di campionamento, in questo studio per\`o non si vedr\'a quest'ultima fase, poich\`e non rilevante ai fini di questa tesi, ma ci concentreremo sulla prima fase.
L'algoritmo inizia con una prima fase di colorazione dove per ogni nodo $ v \in V $ di $ G $ \`e assegnato un colore $ c(v) $, scelto indipendentemente e uniformemente a caso da $ [k] $.
L'obiettivo della fase di costruzione \`e quello di costruire una tabella del conteggio dei treelet.
Per ogni $ v $ e per ogni albero colorato $ T_C $ con $ k $ nodi, si vuole un conteggio $ c(T_C , v) $ del numero di copie di $ T_C $  in $ G $ che sono radicate in $ v $ (si noti che qui si intendono copie non indotte).
A questo fine per ogni $ v $ si inizializza $ c(T_C , v) = 1 $, dove T \`e il treelet triviale di 1 nodo e $ C = \{c_v\} $.
Successivamente si esegue una programmazione dinamica per il conteggio di treelet di dimensione $ h = 2,...,k $.
Per ogni h a turno, si considera ogni possibile albero radicato T con $ h \le k $ nodi e ogni possibile insieme $ C \subseteq [k] $ con $ |C| = h $.
Poi, $ \forall v \in V $,si calcola come segue il numero $ c(T_C,v) $ di occorrenze dei treelet (non indotti) radicati in $ v $ isomorfi a $ T $ e i cui colori giacciono nell'insieme $ C $. Si divide idealmente $ T $ in due sottoalberi radicati $ T' $ e $ T'' $  radicati rispettivamente nella radice $ r $ di $ T $ e in uno dei figli di $ r $.\\
Perci\`o $ c(T_C,v) $ \`e dato come segue:
\begin{equation}\label{conta}
	c(T_c,v)=\frac{1}{\beta_T}\sum_{u\sim v}\sum_{\substack{{C',C''\subset C}\\{C'\cap C'' =0}}}c(T'_{C'},v)\cdot c(T''_{C''},u)
\end{equation}

dove $ \beta_T $ \`e una costante di normalizzazione che \'e uguale al numero di alberi di $ T $ isomorfi a $ T'' $ radicati in un figlio di $ r $. Per calcolare $ c(T_C,v) $ si passa attraverso tutti gli archi $ uv $ di $ G $, combinando i contatori di $ u $ e $ v $. La correttezza e la complessit\`a di questa costruzione, non sono trattate qui,ma vengono dimostrate in \cite{alon1995color}.

\begin{algorithm}[H]
	\SetAlgoLined
	\caption{Fase di costruzione}
	\textbf{input} : Grafo $ G $, dimensione del treelet $ k $ \;
	\For{$ v $ in $ G $}{
		$ C=\{c_v\} $\;
		$ c(T_{c(v)} , v) = 1 $\;
	}
    \For{$ h = 2$ to $ k $}{
    	\For{$ v $ in $ G $}{
    		\ForEach{$ T : |T| = h $}{
    			
    			\( 	c(T_c,v)=\frac{1}{\beta_T}\sum_{u\sim v}\sum_{\substack{{C',C''\subset C}\\{C'\cap C'' =0}}}c(T'_{C'},v)\cdot c(T''_{C''},u) \)
    			
    		}
		}
	}
\end{algorithm}





	
