\chapter{Color Coding}
\label{cap 2}
In questo capitolo verr\`a descritta la tecnica del Color Coding utilizzata in questa tesi.

La tecnica fu introdotta nel 1995 da Alon, Yuster e Zwick \cite{alon1995color}.
In generale, dati due grafi $G$ ed $ H $ , il problema di individuare un sottografo indotto di $ G $ isomorfo ad $ H $ \`e un problema $ NP $-completo, ma pu\`o essere risolto in tempo polinomiale tramite un algoritmo randomizzato per classi particolari di grafi $ H $, usando la tecnica del color coding.

Il primo algoritmo che Alon e i suoi colleghi descrissero in \cite{alon1995color} , per\`o, risolve tale problema quando $ H $ \`e un cammino o un albero con treewidth costante limitandosi, inoltre, alla sola ricerca senza farne un conteggio del numero delle occorrenze totali.
 
In questo capitolo, si presenta un'estensione dell'algoritmo descritto da Alon \cite{alon1995color,bressan2018motif} per effettuare un conteggio delle occorrenze di tutti i treelet all'interno del grafo.\\




\section{Algoritmo}
\label{section1}

Dati in input un grafo $ G=(V,E) $ ed un intero positivo $ k $, per prima cosa il color coding assegna indipendentemente ed uniformemente a caso un \emph{colore}  $c_v \in [k] = \{1,....,k\} $ ad ogni nodo  $ v\in V $ di $ G $.
Dato un sottografo $H$ di $G$, diremo che $H$ è \emph{ben colorato} se ogni nodo $v$ di $H$ ha un colore $c_v$ distinto.

Il cuore dell'algoritmo consiste nel conteggiare il numero di occorrenze (non necessariamente indotte) di alberi ben-colorati di $k$-nodi in $ G $.
Questo viene fatto in maniera efficiente mediante programmazione dinamica, una tecnica che risolve dei sottoproblemi del problema di interesse, procedendo dai problemi ``pi\`u piccoli'' verso quelli ``pi\`u grandi'' e ricostruendo le relative soluzioni in funzione delle soluzioni già calcolate per i problemi precedentemente risolti, fino a risolvere il problema originario.

Nel seguito denoteremo con $ T_C $ un \emph{treelet colorato}, ovvero una coppia $ (T,C) $ dove $ T $ un albero radicato e $ C \subseteq \{1,\dots,k\}$.
Per ogni nodo $ v \in V $ e per ogni treelet colorato $ T_C $, con $ k $ nodi, si vuole calcolare il numero $ c(T_C , v) $ di occorrenze (non indotte) di $ T_C $  in $ G $ che sono radicate in $v$.\\
Inizialmente per ogni nodo $ v $ si inizializza $ c(T_C , v) = 1 $, dove $T$ \`e il treelet di $1$ nodo e $ C = \{c_v\}$.
Dopodichè, per ogni $ h = 2,\dots,k $,  si considera ogni possibile albero radicato $T$ di dimensione $ h $, ogni possibile insieme di colori $ C \subseteq [k] $ con $ |C| = h $ ed ogni nodo $v \in V$.
L'albero $T_C$ viene \emph{decomposto} in due alberi $T'$ e $T''$ come segue: $ T'' $ \`e il sottoalbero radicato in uno dei figli della radice $ v $ di $ T $ e $ T' $ \`e il sottoalbero di $ T $ radicato in $ v $ ottenuto rimuovendo i vertici di $T''$ da $T$.
Ne segue che, per un'opportuna partizione dei colori $C$ in due insiemi $C'$ e $C''$, ogni occorrenza di $T_C$ in $G$ induce l'esistenza di due occorrenze distinte $T'_{C'} = (T', C')$ e $T''_{C''} = (T'', C'')$  in $G$, radicate rispettivamente nei nodi $v$ e $u$.
Viceversa, ogni coppia di occorrenze $T'_{C'}$ e $T''_{C''}$ radicate, rispettivamente, in $v$ e $u$ induce un'occorrenza (non necessariamente distinta) di $T_C$ radicata in $v$.
In particolare è facile osservare che, chiamato $\beta_T$ il numero di sottoalberi di $T$ radicati in un figlio di $r$ isomorfi a $T''$, esistono esattamente $\beta_T$ coppie di occorrenze $T'_{C'}$ e $T''_{C''}$ che inducono $T_C$. 

Dalla discussione precedente segue che, per calcolare $ c(T_C,v)$ è sufficiente considerare tutti treelet colorati radicati in $ v $ isomorfi a $ T'_{C'} $ e tutti i  treelet radicati in un vicino $ u $ di $v$ isomorfi a $ T''_{C''} $, tali che $|C'|=|T'|$\footnote{Dato un albero $\tau$, in questa tesi utilizzeremo la notazione $|\tau|$ per denotare il numero di nodi dell'albero $\tau$.}, $C',C'' \subseteq [k] $ con  $C' \cup C'' = C$ e $C' \cap C'' = \emptyset$.

Sia per $ T' $ che per $ T'' $ \`e noto il numero di occorrenze $ c(T'_{C'},v) $ e $ c(T''_{C''},u) $ in $ G $, poich\`e $|T'|, |T''| \le h-1$. Pertanto:

\begin{equation}\label{conta}
	c(T_c,v)=\frac{1}{\beta_T}\sum_{(u,v)\in E} \;\; \sum_{\substack{C', C'' \subset C : |C'| = |T'| \\C' \cup C'' = C  \\ C' \cap C'' = \emptyset}}c(T'_{C'},v)\cdot c(T''_{C''},u).
\end{equation}

 La correttezza e la complessit\`a di questo algoritmo, non sono trattate in questa tesi, ma vengono dimostrate da Alon in \cite{alon1995color}.\\
 Si pu\`o vedere l'algoritmo formalmente  descritto in Algoritmo \ref{algoritmo}.\\


\begin{algorithm}[H]
	\caption{Algoritmo per il conteggio del numero di occorrenze di $ k $-treelet ben-colorati in $ G $}
	\label{algoritmo}
	\SetAlgoLined
 	\textbf{input} : Grafo $ G =(V,E) $, dimensione del treelet $ k $ ,insieme [$ k $] di colori\;	
 		\For{$ v  \in V$}{
 			Sia $c_v $ un colore scelto uniformemente a caso in [$ k $]\;
 			Sia $T$ il treelet contenente un solo nodo\;
 			$T_C = (T, \{c_v\})$\; 
 			$ c(T_C, v) = 1 $\;
 		}	
 			\For{$ h = 2$ to $ k $}{
 				\For{$ v \in V $}{ \label{ln:for_alg1}
 					\ForEach{$ T : |T| = h $}{
 							Suddivido $ T $ in due alberi $ T'$	 e  $ T'' $ come descritto nella sezione \ref{section1}
 						\( 	c(T_C,v)=\frac{1}{\beta_T}\sum_{(u,v)\in E}\sum_{\substack{C', C'' \subset C : |C'| = |T'| \\C' \cup C'' = C  \\ C' \cap C'' = \emptyset}}c(T'_{C'},v)\cdot c(T''_{C''},u) \)	
 					}
 				}
 			}
 			
\end{algorithm}\mbox{}\\

Come si pu\'o notare, per calcolare le occorrenze di un albero $ T_C $ nell'algoritmo si sfrutta un approccio basato sulle decomposizioni dei treelet, ossia si scompone l'albero $ T_C $ in due alberi $ T' $ e $ T'' $, si considerano tutte le partizioni $ C',C''$ di $C$ e in seguito si procede al calcolo di $ c(T_C,v) $ come indicato in \eqref{conta}.

Ciò richiede di esaminare tutti i possibili alberi colorati $T_C$, il cui numero $\lambda_h$ cresce almeno esponenzialmente con $h$. Infatti, per $h \to +\infty$ (e $h \le k)$, $\lambda_h \to c \cdot \frac{d^h}{h^{3/2}} \cdot \binom{k}{h}$, dove $a=0.4399\dots$ e $d=2.9557\dots$ \cite{knuth1969art}.

Dal momento che il numero di $h$-treelet colorati distinti radicati in ogni nodo $v$ di $G$ è tipicamente di molto inferiore a $\lambda_h$, risulta perciò conveniente esaminare i soli treelet $T_C$ per cui $c(T_c, v) \neq 0$.
A tale scopo e, in questa tesi, come in \cite{bressan2019motivo}, il ciclo for a linea~\ref{ln:for_alg1} dell'algoritmo \ref{algoritmo} è stato implementato come segue:
per ogni arco $(u,v)$ di $G$ e per ogni coppia di treelet colorati $T'_{C'}$ e $T''_{C''}$ radicati, rispettivamente, in $v,u$  si verifica se esiste un albero $T_C$ radicato in $v$ per cui la coppia  $ T'$ e $ T''$ rappresenta una decomposizione ammissibile e tale che $C'$ e $C''$ sono una partizione di $C$ (con $C'$=|T'|). In caso affermativo diremo che l'\emph{unione} tra $T'_{C'}$ e $T''_{C'}$ è l'albero $T_C = (T, C)$.
Ciò richiede di fissare una regola deterministica che, dato $T$, consenta di selezionare l'albero $T''$, radicato in un figlio della radice $r$ di $T$, risultante dalla decomposizione di $T$. A tale scopo si consiera una relazione d'ordine stretto $\prec$ sull'insieme degli $h$-treelet e si seleziona $T''$ come l'albero minimo rispetto a $\prec$ tra tutti i sottoalberi (massimali) di $T$ radicati nei figli di $r$.




Si noti che i conteggi del numero di occorrenze di ogni $ k $-treelet colorato radicato in ogni nodo $ v\in V $ di $ G $, sono calcolati e salvati in maniera indipendente.
Lo scopo di questa tesi per\`o \'e quello di stimare, per ogni $k$-treelet $T^*$, il numero $N(T^*)$ di  sottografi (non necessariamente indotti) isomorfi a $T^*$ nel grafo $ G $.
A tal proposito si noti che ogni occorrenza $O$ di un generico $k$-treelet $T$ in $G$ è responsabile dell'incremento di $1$ di esattamente $k$ contatori $c(T_C, v)$. In particolare tali contatori si riferiscono ai nodi $v$ di $O$ e agli alberi $T_C = (T,C)$ per cui $C = \{1, \dots, k\} $ e $T$ è ottenuto radicando $T^*$ nel nodo corrispondente a $v$.

Sia $\mathcal{T}$ l'insieme di tutti gli alberi isomorfi a $T^*$ e $\widetilde{N}(T^*)$ il numero di occorrenze ben colorate di (sottografi non indotti isomorfi a) $T^*$ in $G$. Dalla discussione precedente segue che:
$\widetilde{N}(T^*) = \frac{1}{k}\sum_{T \in \mathcal{T}} \sum_{v \in V} c( T_C, v)$ dove $T_C = (T, \{1,\dots, k\})$. 
Inoltre, poich\`e ogni occorrenza di un $k$-treelet $T$ in $G$ è ben colorata con probabilità $\frac{k!}{k^k}$, uno stimatore unbiased del numero di $N(T^*)$ è $\frac{k^k}{k!} \cdot \widetilde{N}(T^*)$, cioè
$\mathbb{E}\left[\frac{k^k}{k!} \cdot \widetilde{N}(T^*)\right] = N(T^*)$.



%Quello che è stato fatto in questa tesi per arrivare a calcolare il valore di $ N(T^*) $ sono due passaggi fondamentali.



Un'ottimizazione adottata in questa tesi per il calcolo di $\widetilde{N}(T^*)$ è basata sulla seguente identità:
\[
\widetilde{N}(T^*) = \frac{1}{k}\sum_{T \in \mathcal{T}} \sum_{v \in V} c( T_C, v)
=
\sum_{T \in \mathcal{T}} \sum_{\substack{v \in V \\ c_v = 0}} c( T_C, v).
\]
Ciò implica che, al fine di calcolare $\widetilde{N}(T^*)$, è sufficiente calcolare i conteggi $ c(T_C,v) $ solo per i nodi $v$ di $G$ per cui $ c_v = 0 $ (si noti che la scelta del colore $0$ è arbitraria).


Infine, per aggregare i valori di $c(\cdot, \cdot)$
rispetto alle rispettive classi di equivalenza è sufficiente
selezionare, per ogni insieme di alberi isomorfi $\mathcal{T}$ un rappresentante $\tau \in \mathcal{T}$.
Dato $T$, il rappresentante $\tau$ della classe di equivalenza $\mathcal{T}$ contenente $T$ è ottenuto radicando $T$ in uno dei suoi centroidi\footnote{Si veda la sezione~\ref{cap:3 par:1} per una definizione formale della nozione di centroide di un albero}.
Se $T$ ammette due centroidi $c_1$ e $c_2$ per cui
gli alberi
$T^{(c_1)}$ e $T^{(c_2)}$  ottenuti radicando $T$ in $c_1$ e $c_2$, rispettivamente, sono distinti allora il rappresentante $\tau$ sarà il più piccolo albero tra $T^{(c_1)}$ e $T^{(c_1)}$ rispetto a $\prec$.
In caso contrario $\tau$ sarà l'albero ottenuto radicando $T$ in un centroide arbitrario.





\section{Dettagli implementativi. Rappresentazione compatta dei treelet colorati e rispettivi conteggi}
\label{section 2}
In questa sezione vengono descritte le strutture dati usate per implementare l'algoritmo in Java.
Gli oggetti principali che vengono manipolati sono i treelet colorati e le occorrenze associate.

Ogni treelet colorato $ T_C = (T,C) $ ha una rappresentazione unica nella quale sono memorizzate la topologia di $ T $, i colori in $ C $ ed informazioni aggiuntive per facilitare la minipolazione di $T_C$.
Tale rappresentazione richiede al pi\`u 58 bit e pu\`o pertanto essere memorizzata usando degli interi a 64 bit, un tipo di dati nativo in Java, nelle pi\`u comuni architetture moderne.
I bit sono numerati da 0 a 63 e ordinati dal bit meno significativo a quello pi\`u significativo.\\
Sono cos\'i suddivisi:
\begin{itemize}
	\item i bit da 0-3 contengono il numero di nodi di $ T $ a meno della radice.
	\item i bit da 4-7 contengono la dimensione del sottoalbero radicato nell'ultimo figlio della radice di $ T $.
	\item i bit da 8-11 vengono usati per memorizzare il valore di $ \beta_T $ associato a $ T $.
	\item i bit da 12-27 sono usati per indicare i colori in $ C $.
	\item i bit da 28-58 sono usati per codificare la struttura del treelet, come descritto di seguito.
	\item gli ultimi 5 bit sono lasciati a zero.
\end{itemize}\mbox{}

Per codificare la struttura dell'albero si procede a partire da una visita in profondit\`a (DFS) su $ T $.\\
In questo caso la visita avviene partendo dalla radice $ r $ di $ T $ e attraversando tutti gli archi. Al termine ogni arco sar\`a stato attraversato esattamente 2 volte, in direzioni opposte. \\
Sia $h=|T|$ e sia $e_i$, con $i = 1, 2, \dots, 2(h-1)$, l'$i$-esimo arco attraversato dalla visita. 
L'$i$-esimo bit della codifica \`e $0$ se $e_i$ \`e attraversato in direzione di $r$ in $T$ e $1$ in caso contrario.\\
 In Figura \ref{figura} si pu\`o vedere un esempio di tale codifica.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=11cm]{capitolo2/grafo3}
	\caption{Un treelet radicato e la codifica della sua struttura}
	\label{figura}
\end{figure}

Per un qualunque $ k \le 16 $ questa codifica richiede al massimo 30 bit.
L'ordinamento lessicografico sulla struttura definisce anche implicitamente un'ordinamento totale sui treelet. Questo ordinamento \`e anche una regola decisiva per la visita DFS: i figli di un nodo vengono visitati nell'ordine indotto dai sottoalberi radicati in essi.
Ci\`o implica che ogni treelet $ T $ ha una codifica unica ed ogni codifica valida corrisponde ad un solo treelet. Inoltre, in questo modo \`e possibile implementare rapidamente l'operazione di unione.\\\\
La codifica dei treelet supporta le seguenti operazioni :
\begin{itemize}
	\item $ \textbf{singleton} $ (c) : permette di inizializzare un treelet di un solo nodo con il rispettivo colore $ c \in \{1, \dots, k\} $
	\item $ \textbf{merge} $ ($ T'_{C'} $,$ T''_{C''} $) : fa l'unione di due alberi $ T' $ e $ T'' $ e se possibile crea un nuovo albero $ T $ che avr\`a come struttura la concatenazione delle strutture di $ T' $ e $ T'' $ (a meno della radice).
	La dimensione, a meno della radice, sar\`a data dalla somma delle dimensioni di $ T' $ e $ T'' $ pi\'u 1.
	I colori di $ T $, sono il risultato dell'unione dei colori di $ T' $ e $ T'' $.
	$ \beta_T $ sar\`a, inizialmente, pari al valore $ \beta_{T'} $ corrispondente a $ T' $ e se la struttura del sottoalbero radicato nell'ultimo figlio di $ T' $ \`e uguale alla struttura di $ T'' $ viene eventualmente incrementato di 1.\\
 	 Per finire, la dimensione del sottoalbero pi\`u piccolo radicato in $ T $ sar\`a esattamente la dimensione di $ T'' $, a meno della radice, pi\`u 1 .
	\item $\textbf{normalization\_factor}$ ($ T_C $): restituisce la costante di normalizzazione $ \beta_T $ associata a $ T_C $.
	    
\end{itemize}
\begin{figure}[htbp]
	\centering
	\includegraphics[width=11cm]{capitolo2/grafo5}
	\caption{un treelet colorato $ T_C =(T,C) $ e la sua codifica, mostrata per semplicit\`a solo su 8+8+4+4+4=28 bit}
	\label{figura1}
\end{figure}
 In Figura \ref{figura1} \`e mostrato un esempio di treelet colorato e della sua codifica\\\\
Nell'implementazione i treelet individuati da ogni nodo e i rispettivi conteggi vengono salvati all'interno di una tabella indicizzata, rappresentata mediante strutture annidate di $ ArrayList $.\\
Inizialmente, come nell'algoritmo \ref{algoritmo}, i treelet e i conteggi sono stati valutati su ogni nodo $ v \in V $ di $ G $ scorrendo tutti gli archi $ E $, quello che si ha, perc\`o \`e una tabella con $ k $ entrate indicizzate da $ 1 $ a $ k $ ed associate al numero di vertici dei treelet.\\ 
L'$ i $-esima entrata della tabella, con $ 1\le i \le k $ generico, a sua volta, \`e un $ ArrayList $, con una dimensione fissata, che varia a secondo della cardinalit\`a di $ V $, cos\`i che ad ogni entrata \`e associato un vertice $ v\in V $ di $ G $.\\
Per ognuna delle $ |V| $ entrate, viene creato un $ ArrayList $ contenente tutti i treelet colorati di dimensione $ i $ raggiungibili dai differenti nodi in $ V $, insieme al relativo numero di occorrenze.\\
All'interno di quest'ultima lista i treelet sono ordinati in ordine non descrescente.

Per permettere una costruzione pi\`u rapida della tabella, nell'implentazione \`e utilizzato il $ Multithreading $, cio\`e vengono utilizzati pi\`u thread che lavorano in parallelo.
Un thread \`e un flusso di esecuzione indipendente all'interno di un processo.
Il numero di thread utilizzato nell'implementazione \`e dipendente dal numero di processori presenti nella macchina.





	
